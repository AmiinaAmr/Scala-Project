[0m[[0m[0mdebug[0m] [0m[0m> Exec(collectAnalyses, None, Some(CommandSource(network-1)))[0m
[0m[[0m[0mdebug[0m] [0m[0munmatched Processing event for requestId None: None[0m
[0m[[0m[0mdebug[0m] [0m[0mEvaluating tasks: Compile / collectAnalyses[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: initialized: JsonRpcNotificationMessage(2.0, initialized, {})[0m
[0m[[0m[0mdebug[0m] [0m[0mRunning task... Cancel: Signal, check cycles: false, forcegc: true[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///c%3A/Users/CYTech%20Student/OneDrive/Documents/GitHub/graph_squelette/main.scala","languageId":"scala","version":1,"text":"package undirected\r\nobject main extends App {\r\n\r\n    val vertices= Set(\"A\",\"B\",\"C\",\"D\",\"E\");\r\n    val ed1 = Edge[String](\"A\",\"B\");\r\n    val ed2 = Edge[String](\"B\",\"D\");\r\n    val ed3 = Edge[String](\"E\",\"D\");\r\n    val ed4 = Edge[String](\"E\",\"B\");\r\n\r\n    \r\n\r\n    val edges=Set(ed1,ed2,ed3,ed4);\r\n    val msgr=new SimpleGraphDefaultImpl[String](vertices,edges);\r\n\r\n   println(msgr.hasPath(\"A\",\"C\"));\r\n   // println(msgr.hasPath(\"A\",\"D\"));\r\n   // println(msgr.hasPath(\"A\",\"E\"));\r\n    //println(msgr.greedyColoring);\r\n\r\n    \r\n}\r\n\r\n\r\n\r\n"}})[0m
[0m[[0m[0mdebug[0m] [0m[0manalysis location (C:\Users\CYTech Student\OneDrive\Documents\GitHub\graph_squelette\target\scala-2.13\zinc\inc_compile_2.13.zip,true)[0m
[0m[[0m[32msuccess[0m] [0m[0mTotal time: 0 s, completed Mar 29, 2022 3:01:53 PM[0m
[0m[[0m[0mdebug[0m] [0m[0munmatched Done event for requestId None: None[0m
[0m[[0m[0mdebug[0m] [0m[0m> Exec(shell, None, None)[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///c%3A/Users/CYTech%20Student/OneDrive/Documents/GitHub/graph_squelette/src/main/scala/undirected/SimpleGraph.scala","languageId":"scala","version":1,"text":"package undirected\n\nimport scala.annotation.tailrec\n\n/** Trait for an undirected and ''simple'' graph, that is without loop nor parallel edges\n  * @tparam V type for vertices\n  */\ntrait SimpleGraph[V] {\n    /* QUERY METHODS */\n\n    /** The set of all vertices of the graph */\n    val vertices : Set[V]\n\n    /** The set of all    edges of the graph */\n    val edges : Set[Edge[V]]\n\n    /** The set of all vertices adjacent to input vertex\n      * @param v vertex\n      * @return [[None]] if `v` is not an actual vertex, the set of all neighbors of `v` otherwise (may be empty)\n      */\n    def neighborsOf(v : V) : Option[Set[V]]\n\n    /** The number of adjacent vertices to input vertex\n      * @param v vertex\n      * @return [[None]] if `v` is not an actual vertex, the degree of `v` otherwise\n      */\n    def degreeOf(v : V) : Option[Int] = neighborsOf(v) map { _.size }\n\n    /** Checks if there exists a path between two vertices\n      * @param v1 one end of path to search\n      * @param v2 other end of path to search\n      * @return `true` if `v1` and `v2` are equal or if a path exists between `v1` and `v2`, `false` otherwise\n      */\ndef hasPath(v1 : V, v2 : V) : Boolean = {\n\n      //if(degreeOf(v1)== None || degreeOf(v2) == None) return false;\n\n      if(neighborsOf(v1).get.contains(v2)) return true;//condition d'arret true\n\n      return (neighborsOf(v1).get.map(v=>hasPathAux(v,v2,v1)).contains(true));//Set(x1,x2).map(x=>f(x))=Set(f(x1),f(x2))\n\n     // return false;\n\n    }\n\n    def hasPathAux(v : V, v2 : V,v1:V) : Boolean ={      \n\n      val s=neighborsOf(v).get.-(v1)\n\n      if(s.contains(v2)){return true;}\n\n      if(s.nonEmpty){return s.map(x =>hasPathAux(x,v2,v)).contains(true);}\n\n      return false;\n\n    }\n\n    /** Checks if graph is connected */\n    lazy val isConnected : Boolean = !vertices.map(v1=>vertices.-(v1).map(v2=>hasPath(v1,v2))).flatten.contains(false);\n    /** Checks if graph is acyclic */\n    lazy val isAcyclic : Boolean = !vertices.map(v1=>hasPath(v1,v1)).contains(true);\n\n\n\n    /** Checks if graph is a tree */\n    lazy val isTree : Boolean = isConnected && isAcyclic\n\n    /* VERTEX OPERATIONS */\n\n    /** Add vertex to graph\n      * @param v new vertex\n      * @return the graph with new vertex `v`\n      *         if `v` is an actual vertex of graph, return input graph\n      */\n    def + (v : V) : SimpleGraph[V]\n\n    /** Remove vertex from graph\n      * @param v new vertex\n      * @return the graph without vertex `v`\n      *         if `v` is not an actual vertex of graph, return input graph\n      */\n    def - (v : V) : SimpleGraph[V]\n\n    /* EDGE OPERATIONS */\n\n    /** Add edge to graph (also add edge ends as new vertices if necessary)\n      * @param e new edge\n      * @return the graph with new edge `e`\n      *         if `e` is an actual edge of graph, return input graph\n      */\n    def +| (e : Edge[V]) : SimpleGraph[V]\n\n    /** Remove edge from graph (does NOT remove ends)\n      * @param e new edge\n      * @return the graph without edge `e`\n      *         if `e` is not an actual edge of graph, return input graph\n      */\n    def -| (e : Edge[V]) : SimpleGraph[V]\n\n    /** Remove all edges from graph but keep same vertices\n      * @return graph with same vertices without any edge\n      */\n    def withoutEdge : SimpleGraph[V]\n\n    /** Add all possible edge with same vertices\n      * @return graph with same vertices and all possible edges\n      */\n    def withAllEdges : SimpleGraph[V]\n\n    /* VALUATED GRAPH METHODS */\n\n    /** Total value of the graph\n      * @param valuation valuation used\n      * @return total value of the graph, i.e. sum of values of all edges\n      */\n    def value(valuation : Map[Edge[V], Double]) : Double = (edges map { valuation(_) }).sum\n\n    /** Minimum spanning tree\n      * @param valuation valuation used\n      * @return a spanning tree whose value is minimal\n      */\n       def minimumSpanningTree(valuation : Map[Edge[V], Double]) : SimpleGraph[V] = ???/*{\n\n       if(valuation.size == 1) return this.withoutEdge.+|(valuation.head._1);\n\n       return (this.withoutEdge.+|(valuation.toSeq.sortBy(_._2).head._1))+ minimumSpanningTree(valuation.-(valuation.head))).+|());\n        // To Do : Ajouter la condition de l'acyclic\n       \n       \n\n     \n    }\n\n    */\n    /* COLORING METHODS */\n\n    /** Sequence of vertices sorted by decreasing degree */\n    lazy val sortedVertices : Seq[V] = vertices.map(v=>(v,degreeOf(v))).toMap.toSeq.sortWith(_._2.get>_._2.get).map(_._1).toSeq\n    /** Proper coloring using greedy algorithm (a.k.a WELSH-POWELL) */\n    lazy val greedyColoring = {//: Map[V,Int]\n      val colors=List(0,1,2,3,4,5,6,7,8,9,10,11)\n      sortedVertices.map(v=>(v,sortedVertices.toSet.-(v).filterNot(hasPath(v,_))))\n    }\n        \n\n    /** Proper coloring using DSATUR algorithm */\n    lazy val coloringDSATUR : Map[V, Int] = ???\n\n    /* toString-LIKE METHODS */\n\n    /** @inheritdoc */\n    override lazy val toString : String = s\"({${vertices mkString \", \"}}, {${edges mkString \", \"}})\"\n\n    /** Graph representation in DOT language */\n    lazy val toDOTString : String = {\n        \"strict graph {\\n\" +\n        \"    // Edges\\n\" +\n        (edges foldLeft \"    \") { _ + _.toDOTString + \"\\n    \" } + \"\\n\" +\n        \"    // Vertices\\n\" +\n        vertices.mkString(\"    \", \"\\n    \", \"\\n\") +\n        \"  }\\n\"\n      }\n\n}\n"}})[0m
